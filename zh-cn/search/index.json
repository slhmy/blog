[{"content":"Markdown 是我用的最多的文档语言， 随着文档的增加，我也意识到了双链笔记的重要性，于是我就了解到了 Obsidian。 它的可扩展性做的是比较优秀的，我喜欢它的 graph view， 它能让有关联的文档自动通过 Tag 联系起来。\nObsidian 优秀的使用体验，让我想在更多地方也能够使用它， 比如在自建的静态博客中（或者在像 Docusaurus 这类的知识库框架中）。 但在这些框架中，往往也有不少部分是和 Obsidian 存在冲突的， 比如 Obsidian 并不能支持 MDX， Callout 语法有所区别等\u0026hellip;\n经过一些折腾，终于算是找到了一个比较好的方案， 需要额外安装的插件很少，几乎没有配置的负担，下面分享给各位。\nSyncing 这是所有人都关心的问题，官方的同步方案比较昂贵，很难作为第一手的选择方案。这里我推荐安装：\nRemotely Save 我自己是用的个人版的 Onedrive 来作为存储， 在有多个 Windows 设备时，可以直接在 Onedrive 文件夹中打开 Vault 进行编辑 Git 像博客这种需要使用 GitHub Action 进行发布的情况，有 Git 插件也会更方便一些 如果有 IOS 或 Mac 设备，Obsidian 是天生支持 iCloud 的，但 Windows 的 iCloud 真的很垃圾。 所以我通常是创建一个同名的打开了 iCloud 的 Vault ，再使用 Remotely Save 进行第一次同步， 这样就可以在苹果设备上进行同步了。\nMarkdown 编辑 Obsidian 的 Markdown 使用体验相对来说也是比较传统的，我自己在使用过程中主要遇到了以下两个问题。\n支持 img 标签的相对路径 在 Obsidian 中，我们更多的是使用 ![](url) 的方式来插入图片。 但是由于一些特殊的原因（比如我不想让 Hugo 处理我的 GIF，因为那样会卡住）， 我们还是会需要使用 \u0026lt;img src=\u0026quot;url\u0026quot; /\u0026gt; 的方式来插入图片。\n这时候你就会发现，img 标签是不支持使用相对路径的。 这里我通过 Display Relative Path Img 来解决这个问题，虽然是一个很小众的插件，但目前工作下来，没有出现明显的问题。\nObsidian 中的文章标题 在 Obsidian 中，文章的标题就是 Markdown 文件的名称， 这对很多需要参与建站的 Markdown 文件来说会非常不友好。 比如在 Hugo 当中 Post 的 Markdown 必须是 index.md，而真正的 title 是在 Markdown properties 中配置的。\n因此我们需要使用 Front Matter Title, 在设置里打开 Graph、 Inline、 Search、 Tabs 等覆盖 Feature， 这样就能看到 Markdown properties 中配置的文章标题了。\n","date":"2024-04-21T16:42:51+08:00","permalink":"https://slhmy.github.io/blog/zh-cn/p/blogging-with-obsidian/","title":"使 Obsidian 在博客中发挥作用"},{"content":" 迁移自我的语雀，此项目已经放弃维护，它出现在这里，主要是因为我想测试一下我的博客迁移工具~\n✏️ 前言 随便说说 这个项目对我个人而言，意义比较特殊。它是我的毕业设计课题，但在答辩结束以后，这个项目还是在一直继续的完善开发\u0026hellip;甚至可能直到我离开学校，它有可能还有很长一段路要走。\n我这个人比较讨厌放弃一件自己曾经想做但是又没做成的事情，初中时期成绩一年不如一年的算法竞赛让我大学里还是跳进了 ACM-ICPC 的大坑；退役之后以测试身份加入学校 OJ （Online Judge）平台的开发，但实际上后端根本就没有人会启动起来\u0026hellip;所以实习回到学校以后，才会硬着头皮用Rust再搞了一次。\n这个项目比我预想的要简单一些，对我而言目前它已经不是一个能给我带来进一步提升的项目了，不过如果没有像我这样类似的开发经历的话，它还是有许多地方是值得参考学习的。毕竟我也是从连API规范都搞不清楚，一点点把模块分好，最后又废弃初版重做这样走过来的。这期间的收获还是很多的。\n这篇文章的主要内容 这是一篇介绍博客，主要会说一下项目的大致功能以及涉及到的技术点，具体的技术学习的内容会分享在同系列的笔记当中。\n🍟 SHUpdtp 的大致用途 SHUpdtp （全称：Shanghai University program design training platform），中文名译为上海大学程序设计训练平台，简单来说就是一个高校自用的在线判题系统。同类型的网站在面试和竞赛圈里其实很常见，牛客、力扣应该是全网最家喻户晓的两个（不熟悉的朋友可以访问一下看看）。高校判题系统对比商用判题系统，更多的是承载在线判题的基本功能，拓展功能一般酌情添加，不会像后者做的如此全面（因为本身的受众也更少）。\n在这篇文章的最开头，我配了一张动图（这是我毕业设计答辩时附带的演示用前端，我不是前端专家，这部分就暂时没有打算分享时怎么做的了），动图里展示的就是一个最基本的在线判题系统的使用方法。如果还是有一些不清楚的话，我这里附上一页 PPT \u0026hellip;说实话这块用文字描述挺困难的，建议有兴趣的还是多看看其他同类型的平台，这部分的文字解说我暂时打算简单略过（如果有需要请记得提醒我更新），非常抱歉🤥！\n📉 涉及到的技术点 在线判题系统和很多xxx系统（比如图书管理系统，课程管理系统实际上是同一类），但是 SHUpdtp 有两个不一样的点，一是它是使用 Rust 进行开发，二是在线判题系统需要依赖于判题机实现在线判题功能。所以涉及到的主要技术点主要有以下这些：\n使用 Rust 完成后端开发，确保项目结构清晰，运行稳定 怎么使用 Rust 的 Web 框架和 ORM 框架配合数据库制作 API 接口 如何用某种手段接入和管理附属判题机 还有一些小的细节方面的我就不一一列举了，以上几个技术点还是比较值得学习的，小一些的技术点多数学习价值不高（不过诸如：接入阿里云短信接口\u0026hellip;这样的案例我有空的时候也会来分享的）。\n","date":"2023-08-12T20:00:02+08:00","permalink":"https://slhmy.github.io/blog/zh-cn/p/intro-of-shupdtp/","title":"上海大学程序设计训练平台 SHUpdtp 介绍"},{"content":"前言 写这篇 Post 的起因是我希望有更多的人能参与到我的开源项目中来， 但它是用 Rust 写的，这让不少想要了解这项目的人无法快速加入到其中来。 当然我也希望能通过这篇文章，能够让更多的人不再畏惧对新语言的学习。\n老实说在半年之前，我也会经常畏惧我没有接触过的高级编程语言 （例如：我也曾因为没接触过Go而感到困扰）。 而现在，我已经能够快速适应多种不同高级编程语言的使用 （请注意我说的是高级编程语言）。 到目前为止， 我会在不同情景下使用 Go、Rust、JS/TS、C#、Python、C/C++、Java 这些高级编程语言。 之所以能够快速接触到这么多语言，我认为有一些经验是需要指出的， 无论是在学习 Rust 还是任何一门其他的高级编程语言。\n如何快速入门一个新的高级编程语言 首先，如果你有过几年的编程经验，我不提倡为了学一门语言而去做专项的学习。 因为在没有项目参考的情况下，学习编程语言的成本是比较高的， 这会不明所以地消耗你大量的时间。\n你需要变得自信：高级编程语言本身就是人类可读的文本，基本没有理由看不懂。 会造成困扰的是它们当中不同的语义符号和一些较为特殊的语言机制， 通常来说这些不同会让你在空手进行开发时给你造成比较大的困扰， 但如果仅是进行阅读，理解代码的逻辑含义还是较为轻松的。\n丰富的 RealWorld 项目经历会降低学习的成本。 代码和读书虽然很接近，但也还是略有不同， 因为写的代码层次一旦开始变得复杂，你就需要使用一些常见的方法去帮忙降低构思的复杂度， 例如：面向对象、设计模式、函数式编程等等。 你不一定会在所有语言中使用到它们，但实战经历会让你更方便理解和写出更好的代码。 除此以外，项目中时常会用到扩展依赖，比如说序列化工具、数据库驱动、Web 框架等， 每个语言都有，并且用途和功能都是可以总结的。\n最后，2023年了搞一个 AI 联想帮下忙吧。 在编写自己不熟悉的语言时，陌生的声明式和符号会让人感到懊恼。 AI能帮助你尽可能规避类似的问题，多一份联系也是多了一份参考。\nRust 快速入门 进入正题，其实上面说了那么多，也是为了在这个环节尽量少说一些。 接受下划线标注出的关键点，我认为通常来说已经足够了。 但作为一门相对小众的语言（以及为了能让更多人了解Rust）， 我们还是不得不讨论一些细节的东西。\nRust 的大致画像 以防你可能会问：“Rust 有什么好的？” 类似这样的问题，我会先简要介绍一下Rust的大致画像。\nRust是一门，性能足以和 C/C++ 媲美的，主打标准现代工程化的静态编程语言， 为了实现高效的运行效率和足够现代和安全的开发流程， Rust会比任何同类型的编程语言看上去更加繁琐。 它是一个较好的 C++ 的同类替代品，在较为基础的模块编写上，能够做到非常优秀的工程输出。 对于不熟悉使用 C++ 进行工程开发的人来说， Rust 项目的工具链（cargo）更容易上手，编写的代码也不容易出错。\n语法形式上 Rust 和 Typescript、Scala 等语言类似， 使用这些语言的领域的程序员会更容易上手 Rust。 但同时 Rust 的 unsafe 特性又可以使其下探到系统级别的编程领域， 这些领域也带来一批更加高级的玩法。\nRust 的开源社区破事比较多，但也确实有不少大佬也喜欢使用 Rust。\n我的项目为什么选择 Rust 对我来说 Rust 足够存粹，我可以在任何地方任何场合，快速构建 Rust 的项目环境 （cargo、VSCode+ 插件）。 cargo 这个工具可以帮助我快速引入我想要的依赖，生成足够清晰的文档，并且做好模块划分， 相反我对 C++ 该如何做这些事情并不非常熟悉。 对于未来参与贡献的人来说，我希望在提交代码之前就解决大部分潜在的代码问题， Rust 足够安全的特性大幅度减轻了我的心理负担。 （你写出来的代码通常来说只要通过编译，就不会产生任何无法追查的恶性 BUG）\nRust 的开发工具链 当你在阅读或者开发Rust程序时，你需要安装：\nrustup（包含 cargo）官网地址 VSCode/Clion + Rust 插件包（包含 rust-analyzer）（+tabnine/copilot） 接下来你需要掌握 Cargo 的使用，文档可以参考Cargo Book。 你需要知道如何使用 cargo new/build/run/test + fmt/clippy 的使用，其中 fmt 和 clippy 可以帮助你编写更优秀的代码。\nRust的语法和特性 The Rust Programming Language 是你在感到疑惑时最优先参照的资料，这是最官方的语法教程。 但正如我之前说的一样，我并不建议你在完全没有项目作为出发点的时候去通读这本书， 这很消耗时间。\n接下来我会列出一些小的章节，来解释一些你需要在入门时就习惯的的 Rust 语法和特性。\n【Common】通用语法 这个章节包含的是如何申明变量，如何使用注释和循环等在其他编程语言当中也非常常见的语法。 Common Programming Concepts 和它的子章节基本就能解决所有这些问题，但我同样不建议你直接阅读这些章节， 在我看来这些语法稀疏平常，直接阅读通常也能理解它的含义。\n有可能会带来困扰的是声明相关的内容，不过你只需要了解下面这些就足够了。 如果你想创建一个由名字指代的值，只要这么写就可以了：\n1 let (mut) {value_name}: {type} = {value} 如你所见，类型声明的位置和其他语言是稍有区别的，显然这不是很影响理解 mut 你可能之前并没有见过，它的意思是 mutable， 如果你想创建的时一个变量，你需要在声明时指定 mut。 Rust 的语法是相对繁复的， 这种设计的目的是为了让编写的人时刻清楚，自己具体在做什么。\n【Common】Option 可选变量（入门 Enum 和模式匹配） 我们开始接触一些真正奇怪的东西了， 入门 Rust 第一个坏消息是，你可能不会再见到 Null 或者 nil 了。 （至于为什么这样可以翻阅这个章节：The Option Enum and Its Advantages Over Null Values) 不过好在这件事其实挺容易接受的， Option 会是你在 Rust 当中接触的非常多的一种枚举类型：\n1 2 3 4 enum Option\u0026lt;T\u0026gt; { None, Some(T), } 如果你掌握其他语言中泛型的使用，那么你应该不难理解上面的代码。\n如果你并不清楚什么时泛型，或者说你完全无法理解\u0026lt;\u0026gt;， 可以先尝试阅读 Generic Types, Traits, and Lifetimes 中的 Generic 部分，或者尝试从其他语言中获取参考，请一定记住，你只需要浅显地理解即可\n在展开 Option 包裹的值时，你只会遇到两种情况，一种是 None 一种是有值的 Some。\n那么如何展开一个Enum呢？ 常见的方法有两种 ( match 和 if let )：\n1 2 3 4 5 let config_max = Some(3u8); match config_max { Some(max) =\u0026gt; println!(\u0026#34;The maximum is configured to be {}\u0026#34;, max), _ =\u0026gt; (), } 1 2 3 4 let config_max = Some(3u8); if let Some(max) = config_max { println!(\u0026#34;The maximum is configured to be {}\u0026#34;, max); } 请一定尝试用自然语言的理解方式理解这些代码，我认为这些设计都是足够自然的， 当没枚举类型不是 Option 时也是可以使用的。\n通常来说，当你只专注于解开 Enum 当中一种情况的值时，你可以使用 if let 句式， 从而缩减代码量。\n你不需要担心无法正确地挑选 match 和 if let 句式， 因为你可以在命令行中输入 cargo clippy 来获取代码建议， 如果你的 match 时非常简单的双项选择， cargo clippy 会告诉你如何转换成 if let 的。\n最后，这部分的所有内容都包含在 Enums and Pattern Matching下。\n【Common】Result 错误处理的小问号？ 接下来我们要继续认识下一个特别的枚举类型 Result。 在进行下面的阅读之前，我认为可以提醒你一些小关键点： 如你所见，我单独拿出来举例的都是 Enum 的类型， 这可能会对读者有一定的误导，认为它们各自时特殊的类型。 请记住同一种类型它们是共享同一种特性的，如 match 和 if let 对任何 Enum 都可以使用\n对 Result 来说可以单独拿出来讲的是 ?:\n1 2 3 4 5 6 7 8 9 use std::fs::File; use std::io::{self, Read}; fn read_username_from_file() -\u0026gt; Result\u0026lt;String, io::Error\u0026gt; { let mut username_file = File::open(\u0026#34;hello.txt\u0026#34;)?; let mut username = String::new(); username_file.read_to_string(\u0026amp;mut username)?; Ok(username) } 这是Rust当中上抛错误的简易写法，当上层的 Result 的枚举可以提取上抛的错误类型时， 就可以使用 ? 来使代码在函数返回 Error 的枚举值的时候，直接 return。\n请注意，? 的用法时可以用 match 这种通用方法替代的，它就是在匹配到 Err(_) 时 return 的含义。\n【Common】结构体和面向对象 如果你使用过 Golang 这样的较为新式的编程语言，你可能已经接受了不完整的面向对象的使用。 Rust 也是如此，impl 取代了 Golang 中的接口，使用起来通常比传统的面向对象更加简易。\n我认为在这一部分，你需不需要有太多的学习负担，毕竟这块设计并不是非常有特色的， 因该能快速适应的。 相关的章节在：Using Structs to Structure Related Data。\n对结构体的使用更多是在程序设计方面，出色的设计可以制作出优秀的代码流，可以利用到函数式编程这种优秀的编写方式。\n【Project】模块的编排 我非常讨厌单文本代码，代码量一旦变大，我们就需要把代码拆分成多个文件。 这就会需要考虑我们的代码是否需要进行公开，以及如何在其他地方引用它们。\n1 2 3 4 5 6 7 8 use crate::garden::vegetables::Asparagus; pub mod garden; fn main() { let plant = Asparagus {}; println!(\u0026#34;I\u0026#39;m growing {:?}!\u0026#34;, plant); } 你需要掌握两种标记，pub 和 use：\npub 很容易理解，就是公开模块中的某个元素（元素可以是，函数、结构体、结构体中的成员等） use 用于引用我们需要使用的元素模块，其后会跟随一串路径，路径的开头可能会有些特殊的起始标记，例如 crate 和 super，前者是项目的起始路径标记，后者是同级模块的相对路径起始标记。 你可以在遇到疑惑时再翻阅下面的文档 Managing Growing Projects with Packages, Crates, and Modules\n【Magic】生命周期 压轴部分，也是 Rust 当中最难以理解的特性之一，它在教程的第三章就进行了介绍： Understanding Ownership。 Rust还有一些其他的高级用法，但生命周期是你几乎无法规避的， 它的存在造就了 Rust 既块有编写安全的特征，也使代码的编写不那么顺心如意。\n在 Rust 的设计当中，任何非常量的值，默认只存活于它的作用域当中，且只有一个真正的实体。\n我稍微修改了一份官方的例子，这个例子在其他编程语言中通常是能通过编译的，但是 Rust 不行。 原因就是上面的规约造成的，在 let s3 = takes_and_gives_back(s2); 执行时，s2 的实体已经发生了转移。\nRust 的编写过程当中，非常大部分的编译报错都是由不合法的生命周期造成的。 对此你需要额外地进行一些适应，但请理解，这也可以帮助你在较低的关注成本下关注到每个值的分配和释放的情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 fn main() { let s1 = gives_ownership(); // gives_ownership moves its return // value into s1 let s2 = String::from(\u0026#34;hello\u0026#34;); // s2 comes into scope let s3 = takes_and_gives_back(s2); // s2 is moved into // takes_and_gives_back, which also // moves its return value into s3 // !!! WILL FAILED TO COMPILE !!! let s4 = takes_and_gives_back(s2); } // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing // happens. s1 goes out of scope and is dropped. fn gives_ownership() -\u0026gt; String { // gives_ownership will move its // return value into the function // that calls it let some_string = String::from(\u0026#34;yours\u0026#34;); // some_string comes into scope some_string // some_string is returned and // moves out to the calling // function } // This function takes a String and returns one fn takes_and_gives_back(a_string: String) -\u0026gt; String { // a_string comes into // scope a_string // a_string is returned and moves out to the calling function } 要修复上面的编译报错也很简单，只需对 s2 进行拷贝即可 let s3 = takes_and_gives_back(s2.clone()); 。 在很多语言，例如 Golang 和 Java 中这一动作是自动发生的， 而在 Rust 当中，你需要在代码中体现这一个动作。\n【Magic】宏和代码生成 宏是 Rust 的一种高级特性，但作为入门者你不需要过于担心，我不曾深入过宏的使用， 在这里提到宏，仅仅是因为你会在代码里看到它们，它能提供更加灵活的功能构建，为代码的编写带来便利。 作为使用者，我通常用它完成输入输出日志、格式化字符串、添加（反）序列化、编写 WebHandler 等高级功能。\n宏会以三种形式出现：\nmacro_name!(...) 这种宏的使用无异于函数，也叫做函数宏，只是在函数名后有 ! 标注， 它能带来比函数更加灵活的使用，典型的代表就是 format!/println!() 宏。 #[...] 如果你接触过 C# 的 Attribute，理解这种宏会更加简单，它叫属性宏，可以出现在非常多的代码块的头部 （比如 Enum、struct、func 等，也可以出现在文件的头部）为这些代码块添加属性，可以使代码块获得额外的能力 #[derive(...)] 你可以理解派生宏为一种特殊的属性宏，但它只能作用于 Enum 和 struct 之上 你可以理解宏是通过某种声明实现的 Rust 代码的生成能力，宏在编译时会在 target 当中自动生成一串相应的代码， 通常来说你不需要了解具体它们是如何生成的。\n更多可以参考文档 Macros\n结语 以上就是我认为你需要快速学习 Rust 所需要的全部了， 在最后我对自己所写的内容进行一些反思。\n我试图让 Rust 的具体部分变得更加地简短易懂，单我不认为我做的非常出色。 我通过接受难易程度，对语法和特性进行了排列，但知识结构依旧显得较为平面。\n所以在最后，我为每个小章节加上了标头，Common、Project、Magic， 我认为在任何语言时，可以对语法和特性进行这三大块的分类， 其中前两者通常不会带来较多的学习成本， 而 Magic是可能带来困扰，但也是真正能产生差异的部分（例如 Golang 的协程，JS/TS 的 Promise 等）。 在消化Magic部分的内容时，请务必明白它解决的是什么样的一个问题。\n我在文章中有大量的内容提到了，我不希望各位在入门时就对特性进行过多的深挖， 因为这是一种很消耗时间的行为，但并不是说完全拒绝类似源码阅读这样的事情。 只是这些事情通常不应该在初学时就发生，但如果你是位相关经验较为丰富的“初学者”， 阅读源码也是被允许的，这可能可以帮助你更好地理解一些事情。\n(全文终)\n😩 写的好累，希望各位喜欢 💕\n📕 ~欢迎在评论区给我留言~ ⌨️\n","date":"2023-07-02T16:33:00+08:00","permalink":"https://slhmy.github.io/blog/zh-cn/p/learn-rust-with-a-glance/","title":"快速学习 Rust 编程语言"},{"content":"前言 制作游戏一直都是我比较感兴趣的一件事情。 这次有时间自己尝试了一下，发现过程上其实还挺简单的， 关键的可能还是需要对前端有一些基本的认识，然后知道 WebGL、WebAssembly 啥的， 这样在实践的时候不会在大方向上出现问题。\n这篇文章会复现整个项目的制作流成，目的是提供一个大致清晰的制作方向给大家。\n制作你的Unity游戏 这块会使用到的就是一个比较成熟的 Unity 工具链。 这个例子当中，我使用的是一个 Unity 社区当中的教程模板 Karting Microgame， 你可以在 Unity Hub 中新建项目的时候找到它的模板。 这个模板中会简单的教会你一些 Unity 的使用（包括测试、修改属性、添加物体、发布等）， 当你简单地对 Unity 有了了解之后，你就可以尝试打包发布你的游戏。\n打包完成之后你会得到如下图所示的目录结构：\n其中 Build 目录下的就是我们游戏打包出来的主体，其它外部的是一些默认的配置和资源。 我们可以利用 Node 的 http-server， 在 WebGL Builds（或者对应的打包出来的根目录）起一个 HTTP Server， 这样就可以在浏览器中看到游戏是否在正常运行。\n打包时可能会遇到的问题 在 Unity 默认配置下打包的时候，可能发布出来的游戏在加载阶段会报无法加载 gzip 的报错，修改了 HTTP Server 的配置可能还是会出同样的报错。\n这个问题目前判断下来是因为 Unity 内核的一些问题导致， 所以可能需要修改一下在 Edit/Project Settings/Player/Settings for WebGL 下的打包目标的配置， 配置方法可以参考下图：\n将Unity游戏嵌入到React项目当中 这里就是使用了一个 Node 的依赖，React Unity WebGL\n大致的使用方法如下:\n1 2 3 4 5 6 7 8 9 10 11 12 export default function DashboardPage() { const { unityProvider } = useUnityContext({ loaderUrl: \u0026#34;/game/build/kart.loader.js\u0026#34;, dataUrl: \u0026#34;/game/build/kart.data.unityweb\u0026#34;, frameworkUrl: \u0026#34;/game/build/kart.framework.js.unityweb\u0026#34;, codeUrl: \u0026#34;/game/build/kart.wasm.unityweb\u0026#34;, }); return ( \u0026lt;Unity unityProvider={unityProvider} style={{ width: 800, height: 600 }} /\u0026gt; ); } 这是一个比较简单的使用例子，可以看到在 useUnityContext 中，我们提供的信息其实就是之前介绍到的主体。\n","date":"2022-09-11T11:22:00+08:00","image":"https://slhmy.github.io/blog/zh-cn/p/unity-game-in-web/preview_hu3ae842356df3d24ddb4d7276a9bec92b_472490_120x120_fill_box_smart1_3.png","permalink":"https://slhmy.github.io/blog/zh-cn/p/unity-game-in-web/","title":"Unity 游戏发布到浏览器"},{"content":"前情提要是这样的：\n我昨天参加了我非常喜欢的某公司的全栈开发工程师的面试， 在介绍了我各种过往奇奇怪怪的（真的是非常奇怪的，面试官听了以后直皱眉😂）项目之后， 面试官开始考核我的一些实战能力。 然后上来的第一道代码设计的题目就把我考到了，要我用协程实现多生产多消费，并且能控制协程创建退出。\n可能是我 Golang 只接触了一个月左右的时间， 虽然之前确实有一次被考到 channel 的用法（但复盘的时候也就是简单补习了一下 make channel）。 这次上来直接动手要写代码，还是很多反应不过来，我直接就寄了\u0026hellip; 查了一会 channel 的用法，后面憋出几行又发现为了不让进程过早退出还要使用 waitGroup 这些😇。 然后上面说到的模型确实比较重要的，毕竟我简历上也吹嘘自己掌握各种异步任务设计\u0026hellip; 结果就是啪啪打脸。\n于是在这场被虐的非常惨烈的面试之后，我决定把这样一个生产消费模型好好补一下。 最后补习完了以后发现，大量的内容还是跟 Golang 的 channel 用法有关，那么这篇文章就主要对其做一个梳理。\n基础 我不会讲太多，因为很多地方可以查到，介绍的肯定也更详细。 这里只是提供一个较快的了解。\nchannel 首先对 channel 需要掌握它的类型声明、创建和操作方法。\nchannel的类型声明 在Golang当中，我们通过 [VARIABLE NAME] \u0026lt;-chan | chan | chan\u0026lt;- [TYPE] 这样的句式来声明一个 channel 和它内部的数据类型。 这里 chan 有点像一个前缀的修饰词，可能由于是关键字的原因，在用法上和普通泛型上有区分。 我认为关键是要使用象形的记忆方式，把 chan 本身就想象成一个管道，你可以在 chan 的两侧用 \u0026lt;- 来标记 chan 在这个作用域中的可以使用的端口是写端还是读端，没有标记时代表允许双端的操作\nchannel的创建 通过 make 我们可以创建一个 channel ，这里值得注意的是 make 分配的容量是根据对象的原子个数分配的。 像 string 类型，分配的是字符串的长度，这里是容易理解错的。 但如果你是创建的一个 struct，那分配的容量是“多少个struct”。\nchannel的操作 chan 最基本的操作就是写值和取值操作。\n写值的语法是 [CHANNEL] \u0026lt;- [VARIABLE] | [VALUE]，是象形的操作方式。\n取值的语法是 [VARIABLE] := \u0026lt;-[CHANNEL]，代表从写端取值， 此外还有和 range 一起使用的一些语法糖（这里就不过多介绍了）。\nContext Context 的中文含义是上下文，这类设计其实在很多服务框架中有做到。 像在Rust的一些Web框架中，会有 app.data 的设计，这样做的目的主要就是方便线程/协程之间实现数据的共享。\n在Golang当中，我认为 Context 也起到了类似的作用。 但在这样一个功能的基础上，Context 还提供了一些特殊字段和控制方法，用来实现对协程的控制。 最重要的一种用法如下：\n1 2 3 4 5 6 7 select { case \u0026lt;- ctx.Done(): return default: // normal works when this goroutine is up // ... } 我们通过 ctx.Done 这个管道来判断协程是否需要终止， 这个管道的消息可以通过设置 TimeOut 或者手动 cancel 等方法来发送。 具体可以查阅相关的资料。\nPractice 最后我们来提一下多生产多消费这个模型的实践。 思路其实很简单，我们需要创建一个 channel 来作为消息队列，另外我们还需要一个 Context 来控制协程的退出。\n我们首先定义消息的格式，并准备 channel 和 Context。\n1 2 3 4 5 6 7 8 9 type Message struct { Content string } func main() { var ctx, cancel = context.WithCancel(context.Background()) dataChannel := make(chan Message) countChannel := make(chan int, 1) // ... dataChannel 是用来生产的消息队列，countChannel 是生产者之间用来协同控制消息号的。 由于 countChannel 的读写会发生在一个生产者当中，我们需要设置一个大小为1的缓冲， 每次生产者进行生产之前，生产者会先读取缓冲中的值，并把最新的消息号更新。\n最后结合 Context 的基本用法，我们得到的核心逻辑如下：\nProducer 核心逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 select { // Handle \u0026lt;-ctx.Done() case \u0026lt;-ctx.Done(): fmt.Printf(\u0026#34;Producer_%d quit\\n\u0026#34;, id) return default: // Get message count Count := \u0026lt;-countCh Count += 1 countCh \u0026lt;- Count // Produce dataCh \u0026lt;- Message{ Content: fmt.Sprintf(\u0026#34;Producer_%d sending message_%d\u0026#34;, id, Count), } time.Sleep(1 * time.Second) } Consumer 核心逻辑 1 2 3 // Consume data := \u0026lt;-dataCh fmt.Printf(\u0026#34;Consumer_%d get message: %s\\n\u0026#34;, id, data.Content) ","date":"2022-09-03T11:09:00+08:00","image":"https://slhmy.github.io/blog/zh-cn/p/go-pc-control-model/cover_hu953e2c72d9b12b806d89fab0806c539c_42271_120x120_fill_box_smart1_3.png","permalink":"https://slhmy.github.io/blog/zh-cn/p/go-pc-control-model/","title":"Golang 生产消费控制模型"},{"content":"单调栈是一个很简单的数据结构，但我在做单调栈题目的时候经常一时间想不起来要用它。 这是一件很奇怪的事情，因为单调栈确实是一个“看一眼就会的”那种\u0026hellip; 之所以出现这样的情况，道理其实很简单：对单调栈凸显的本质还不够了解。\n单调栈的本质 其实单调栈的本质也很简单，我们用拆词的方法区理解它。\n首先是单调，它描述了栈里元素的排列状态， 它是从上到下（或者从下到上）有序排列的这么一个形式。\n接下来是栈，栈代表通常在某个状态下，我们只关心栈的顶端是什么元素。\n问题配对 知道本质以后，我们需要反过来去想，单调栈适合去解符合什么样特点的问题。\n首先有序的特点约束了单调栈，它只适合去解决一些分析顺序是有序的问题， 也就是说，如果题目要求是随机查询这种，那么在不事先打表的情况下，单调栈是不能解决这类问题的。\n另外对栈的单端特点来说，它其实隐含了，类似下一个最大（或者最小）这种信息， 因为我们似乎并不需要去关注栈里的其它内容，所以是在某个状态下，求最值的一种场景。 从另外一方面去看，在只关注最值的情况下，其它部分的值是又被忽略的， 所以单调栈还有着在遍历期间忽略数据噪音的特性 （Ex. 忽略右侧最小的时候，我们并不关系右侧其它较大的值，这时候就可以用单调栈来解决）\n","date":"2022-09-01T20:56:00+08:00","permalink":"https://slhmy.github.io/blog/zh-cn/p/monotone-stack/","title":"单调栈"},{"content":"Hooks 【知乎】react-hooks原理解析\n常见钩子：\nuseState useEffect useContext useReducer useRef 生命周期：挂载 \u0026ndash;\u0026gt; 更新 \u0026ndash;\u0026gt; 卸载\nVirtual Dom 参考链接： 【知乎】剖析React核心设计原理\u0026ndash;Virtual Dom\nVirtual Dom的作用 Virtual Dom是对HTML Dom的JavaScript形式的封装\nVirtual DOM是一种编程方式，它以对象的形式保存在内存中，它描述了我们DOM的必要信息，并且用类似react-dom等模块与真实DOM同步，这一过程也叫协调(reconciler)，这种方式可以声明式的渲染相应的ui状态，让我们从DOM操作中解放出来\n我理解有了Virtual Dom之后，弱化了开发者对于原生HTML Dom的感知，这样更方便我们在JavaScript层面去修改页面的动态元素。\n","date":"2022-08-31T19:00:00+08:00","permalink":"https://slhmy.github.io/blog/zh-cn/p/react-hooks/","title":"React 基础"}]